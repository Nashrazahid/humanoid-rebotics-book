"use strict";(globalThis.webpackChunkhumanoid_robotics_book=globalThis.webpackChunkhumanoid_robotics_book||[]).push([[932],{2725:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>t,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>c});var s=i(4848),o=i(8453);const r={title:"Forward and Inverse Kinematics",sidebar_position:2},t="Forward and Inverse Kinematics",a={id:"module2/chapter5-forward-inverse-kinematics",title:"Forward and Inverse Kinematics",description:"Learning Outcomes",source:"@site/docs/module2/chapter5-forward-inverse-kinematics.md",sourceDirName:"module2",slug:"/module2/chapter5-forward-inverse-kinematics",permalink:"/humanoid-robotics-book/docs/module2/chapter5-forward-inverse-kinematics",draft:!1,unlisted:!1,editUrl:"https://github.com/your-username/humanoid-robotics-book/edit/main/docs/module2/chapter5-forward-inverse-kinematics.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Forward and Inverse Kinematics",sidebar_position:2},sidebar:"docs",previous:{title:"Mechanical Design Principles",permalink:"/humanoid-robotics-book/docs/module2/chapter4-mechanical-design-principles"},next:{title:"Dynamics and Motion Planning",permalink:"/humanoid-robotics-book/docs/module2/chapter6-dynamics-motion-planning"}},l={},c=[{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Key Concepts",id:"key-concepts",level:2},{value:"Forward Kinematics",id:"forward-kinematics",level:3},{value:"Mathematical Representation",id:"mathematical-representation",level:4},{value:"Denavit-Hartenberg (DH) Convention",id:"denavit-hartenberg-dh-convention",level:4},{value:"DH Parameters",id:"dh-parameters",level:4},{value:"Inverse Kinematics",id:"inverse-kinematics",level:3},{value:"Challenges",id:"challenges",level:4},{value:"Approaches",id:"approaches",level:4},{value:"Workspace Analysis",id:"workspace-analysis",level:3},{value:"Types of Workspace",id:"types-of-workspace",level:4},{value:"Visuals and Diagrams",id:"visuals-and-diagrams",level:2},{value:"Examples and Demos",id:"examples-and-demos",level:2},{value:"Example 1: Forward Kinematics Calculation",id:"example-1-forward-kinematics-calculation",level:3},{value:"Example 2: Inverse Kinematics Challenges",id:"example-2-inverse-kinematics-challenges",level:3},{value:"Example 3: Pseudocode for Jacobian-based IK",id:"example-3-pseudocode-for-jacobian-based-ik",level:3},{value:"Theoretical Foundations",id:"theoretical-foundations",level:2},{value:"Linear Algebra",id:"linear-algebra",level:3},{value:"Screw Theory",id:"screw-theory",level:3},{value:"Differential Kinematics",id:"differential-kinematics",level:3},{value:"Validation and Testing",id:"validation-and-testing",level:2},{value:"Concept Check: Kinematics Solutions",id:"concept-check-kinematics-solutions",level:3},{value:"References",id:"references",level:2}];function d(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"forward-and-inverse-kinematics",children:"Forward and Inverse Kinematics"}),"\n",(0,s.jsx)(n.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,s.jsx)(n.p,{children:"After completing this chapter, you will be able to:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Define forward and inverse kinematics problems"}),"\n",(0,s.jsx)(n.li,{children:"Apply the Denavit-Hartenberg (DH) convention for kinematic modeling"}),"\n",(0,s.jsx)(n.li,{children:"Solve forward kinematics using transformation matrices"}),"\n",(0,s.jsx)(n.li,{children:"Understand the challenges and approaches for inverse kinematics"}),"\n",(0,s.jsx)(n.li,{children:"Implement kinematic solutions for humanoid robots"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsx)(n.p,{children:"Kinematics is the study of motion without considering the forces that cause it. In robotics, kinematics deals with the relationship between joint positions and the position and orientation of the robot's end-effector. Forward kinematics calculates the end-effector pose from known joint angles, while inverse kinematics determines the required joint angles to achieve a desired end-effector pose. For humanoid robots with redundant manipulator structures, these problems become particularly complex and require sophisticated mathematical approaches."}),"\n",(0,s.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,s.jsx)(n.h3,{id:"forward-kinematics",children:"Forward Kinematics"}),"\n",(0,s.jsx)(n.p,{children:"Forward kinematics determines the position and orientation of the end-effector given the joint angles. This is generally a well-posed problem with a unique solution."}),"\n",(0,s.jsx)(n.h4,{id:"mathematical-representation",children:"Mathematical Representation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Transformation Matrices"}),": 4x4 matrices that represent position and orientation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Homogeneous Coordinates"}),": 4x1 vectors that represent points in 3D space"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Chain Multiplication"}),": Sequential multiplication of transformations from base to end-effector"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"denavit-hartenberg-dh-convention",children:"Denavit-Hartenberg (DH) Convention"}),"\n",(0,s.jsx)(n.p,{children:"A systematic method for assigning coordinate frames to robot joints:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Z-axis"}),": Along the joint axis of motion"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"X-axis"}),": Along the common normal between consecutive z-axes"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Y-axis"}),": Completes the right-handed coordinate system"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"dh-parameters",children:"DH Parameters"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"a (link length)"}),": Distance along x-axis from one z-axis to the next"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"\u03b1 (link twist)"}),": Angle about x-axis from one z-axis to the next"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"d (link offset)"}),": Distance along z-axis from one x-axis to the next"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"\u03b8 (joint angle)"}),": Angle about z-axis from one x-axis to the next"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"inverse-kinematics",children:"Inverse Kinematics"}),"\n",(0,s.jsx)(n.p,{children:"Inverse kinematics determines the joint angles required to achieve a desired end-effector position and orientation. This is often an ill-posed problem with multiple or no solutions."}),"\n",(0,s.jsx)(n.h4,{id:"challenges",children:"Challenges"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Multiple Solutions"}),": Redundant robots have infinite solutions"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"No Solution"}),": Desired pose may be outside the workspace"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Singularities"}),": Loss of degrees of freedom at certain configurations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Computational Complexity"}),": Analytical solutions often intractable for complex robots"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"approaches",children:"Approaches"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Analytical Methods"}),": Closed-form solutions for simple kinematic chains"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Numerical Methods"}),": Iterative approaches like Jacobian-based methods"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Geometric Methods"}),": Trigonometric solutions for specific configurations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Optimization-Based"}),": Formulating as optimization problem with constraints"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"workspace-analysis",children:"Workspace Analysis"}),"\n",(0,s.jsx)(n.p,{children:"The workspace is the set of all possible end-effector positions and orientations."}),"\n",(0,s.jsx)(n.h4,{id:"types-of-workspace",children:"Types of Workspace"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Dexterous Workspace"}),": All positions with all orientations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Reachable Workspace"}),": All positions with at least one orientation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Orientation Workspace"}),": All orientations at a given position"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"visuals-and-diagrams",children:"Visuals and Diagrams"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"DH Convention Example:\nz1    z2\n |     |\n |     |     x2\n *-----O-----*-----\x3e\n |     |     |\nx1    x1    x2\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Forward Kinematics:\n[q1, q2, ..., qn] \u2192 [T] \u2192 [x, y, z, \u03b1, \u03b2, \u03b3]\nJoint Angles    Transformation   End-Effector Pose\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Inverse Kinematics:\n[x, y, z, \u03b1, \u03b2, \u03b3] \u2192 [q1, q2, ..., qn]\nDesired Pose       Joint Angles\n"})}),"\n",(0,s.jsx)(n.h2,{id:"examples-and-demos",children:"Examples and Demos"}),"\n",(0,s.jsx)(n.h3,{id:"example-1-forward-kinematics-calculation",children:"Example 1: Forward Kinematics Calculation"}),"\n",(0,s.jsx)(n.p,{children:"For a simple 2-link planar manipulator:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Link lengths: a1, a2"}),"\n",(0,s.jsx)(n.li,{children:"Joint angles: \u03b81, \u03b82"}),"\n",(0,s.jsxs)(n.li,{children:["End-effector position:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["x = a1",(0,s.jsx)(n.em,{children:"cos(\u03b81) + a2"}),"cos(\u03b81+\u03b82)"]}),"\n",(0,s.jsxs)(n.li,{children:["y = a1",(0,s.jsx)(n.em,{children:"sin(\u03b81) + a2"}),"sin(\u03b81+\u03b82)"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"example-2-inverse-kinematics-challenges",children:"Example 2: Inverse Kinematics Challenges"}),"\n",(0,s.jsx)(n.p,{children:"In a 7-DOF humanoid arm:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Redundancy"}),": Multiple joint configurations achieve same end-effector pose"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Optimization"}),": Additional criteria needed (e.g., joint limit avoidance)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Singularities"}),": Configurations where manipulability is reduced"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"example-3-pseudocode-for-jacobian-based-ik",children:"Example 3: Pseudocode for Jacobian-based IK"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"function jacobian_inverse_kinematics(target_pose, current_joints):\n    for i in range(max_iterations):\n        current_pose = forward_kinematics(current_joints)\n        error = pose_difference(target_pose, current_pose)\n\n        if norm(error) < tolerance:\n            return current_joints\n\n        jacobian = compute_jacobian(current_joints)\n        joint_delta = jacobian_pseudo_inverse * error\n        current_joints += joint_delta\n\n    return current_joints  // May not reach target\n"})}),"\n",(0,s.jsx)(n.h2,{id:"theoretical-foundations",children:"Theoretical Foundations"}),"\n",(0,s.jsx)(n.h3,{id:"linear-algebra",children:"Linear Algebra"}),"\n",(0,s.jsx)(n.p,{children:"Essential for representing transformations and solving systems of equations in kinematic calculations."}),"\n",(0,s.jsx)(n.h3,{id:"screw-theory",children:"Screw Theory"}),"\n",(0,s.jsx)(n.p,{children:"Advanced mathematical framework for representing rigid body motions and their composition."}),"\n",(0,s.jsx)(n.h3,{id:"differential-kinematics",children:"Differential Kinematics"}),"\n",(0,s.jsx)(n.p,{children:"Relationship between joint velocities and end-effector velocities through the Jacobian matrix."}),"\n",(0,s.jsx)(n.h2,{id:"validation-and-testing",children:"Validation and Testing"}),"\n",(0,s.jsx)(n.h3,{id:"concept-check-kinematics-solutions",children:"Concept Check: Kinematics Solutions"}),"\n",(0,s.jsx)(n.p,{children:"Which statement about inverse kinematics is true?"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"It always has a unique solution"}),"\n",(0,s.jsx)(n.li,{children:"It is generally easier than forward kinematics"}),"\n",(0,s.jsx)(n.li,{children:"It can have multiple solutions or no solution"}),"\n",(0,s.jsx)(n.li,{children:"It is always well-posed"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Answer: 3. It can have multiple solutions or no solution"}),"\n",(0,s.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,s.jsx)(n.p,{children:"[1] Craig, J. J. (2005). Introduction to robotics: mechanics and control. Pearson Education."}),"\n",(0,s.jsx)(n.p,{children:"[2] Spong, M. W., Hutchinson, S., & Vidyasagar, M. (2020). Robot modeling and control. John Wiley & Sons."}),"\n",(0,s.jsx)(n.p,{children:"[3] Siciliano, B., & Khatib, O. (Eds.). (2016). Springer handbook of robotics. Springer."}),"\n",(0,s.jsx)(n.p,{children:"[4] Murray, R. M., Li, Z., Sastry, S. S., & Sastry, S. S. (1994). A mathematical introduction to robotic manipulation. CRC press."})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>t,x:()=>a});var s=i(6540);const o={},r=s.createContext(o);function t(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:t(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);